{"version":3,"file":"useFilteredSessionsData-DTLVtyFE.js","sources":["../../src/contexts/SessionsFiltersContext.tsx","../../src/hooks/useFilteredSessionsData.ts"],"sourcesContent":["\nimport * as React from 'react';\nimport { ReactNode } from 'react';\nimport { getPreviousMonthDateRange } from '@/utils/dateUtils';\n\ninterface SessionsFilters {\n  locations: string[];\n  trainers: string[];\n  classTypes: string[];\n  dayOfWeek: string[];\n  timeSlots: string[];\n  dateRange: { start: Date | null; end: Date | null };\n}\n\ninterface SessionsFiltersContextType {\n  filters: SessionsFilters;\n  updateFilters: (newFilters: Partial<SessionsFilters>) => void;\n  clearFilters: () => void;\n  clearAllFilters: () => void;\n}\n\nconst SessionsFiltersContext = React.createContext<SessionsFiltersContextType | undefined>(undefined);\n\nexport const useSessionsFilters = () => {\n  const context = React.useContext(SessionsFiltersContext);\n  if (!context) {\n    console.error('useSessionsFilters must be used within a SessionsFiltersProvider. Returning fallback values.');\n    // Return a fallback context\n    return {\n      filters: {\n        locations: [],\n        trainers: [],\n        classTypes: [],\n        dayOfWeek: [],\n        timeSlots: [],\n        dateRange: { start: null, end: null }\n      },\n      updateFilters: () => {},\n      clearFilters: () => {},\n      clearAllFilters: () => {}\n    };\n  }\n  return context;\n};\n\ninterface SessionsFiltersProviderProps {\n  children: ReactNode;\n}\n\nexport const SessionsFiltersProvider: React.FC<SessionsFiltersProviderProps> = ({ children }) => {\n  const [filters, setFilters] = React.useState<SessionsFilters>(() => {\n    const previousMonth = getPreviousMonthDateRange();\n    return {\n      locations: [],\n      trainers: [],\n      classTypes: [],\n      dayOfWeek: [],\n      timeSlots: [],\n      dateRange: { \n        start: new Date(previousMonth.start), \n        end: new Date(previousMonth.end) \n      }\n    };\n  });\n\n  const updateFilters = (newFilters: Partial<SessionsFilters>) => {\n    setFilters(prev => ({ ...prev, ...newFilters }));\n  };\n\n  const clearFilters = () => {\n    const previousMonth = getPreviousMonthDateRange();\n    setFilters({\n      locations: [],\n      trainers: [],\n      classTypes: [],\n      dayOfWeek: [],\n      timeSlots: [],\n      dateRange: { \n        start: new Date(previousMonth.start), \n        end: new Date(previousMonth.end) \n      }\n    });\n  };\n\n  const clearAllFilters = clearFilters;\n\n  return (\n    <SessionsFiltersContext.Provider value={{\n      filters,\n      updateFilters,\n      clearFilters,\n      clearAllFilters\n    }}>\n      {children}\n    </SessionsFiltersContext.Provider>\n  );\n};\n","\nimport { useMemo, useContext } from 'react';\nimport { SessionData } from '@/hooks/useSessionsData';\nimport { useSessionsFilters } from '@/contexts/SessionsFiltersContext';\n\nexport const useFilteredSessionsData = (data: SessionData[]) => {\n  // Try to get filters context, but don't throw if it doesn't exist\n  let filters = null;\n  try {\n    const context = useSessionsFilters();\n    filters = context.filters;\n  } catch (error) {\n    // If we're not within a SessionsFiltersProvider, just use the data as-is\n    filters = null;\n  }\n\n  const filteredData = useMemo(() => {\n    if (!data) return [];\n\n    return data.filter(session => {\n      // Only exclude sessions that are clearly test/invalid data\n      // Allow empty sessions and low attendance sessions to be counted\n      const sessionName = session.sessionName?.toLowerCase() || '';\n      \n      // Only exclude if it's clearly test data or invalid\n      if (sessionName.includes('test') || sessionName.includes('demo')) {\n        return false;\n      }\n\n      // Only apply global filters if we have a filter context\n      if (!filters) {\n        return true; // No filters available, return all data that passed basic exclusions\n      }\n\n      // Apply global filters\n      if (filters.trainers.length > 0 && !filters.trainers.includes(session.trainerName)) {\n        return false;\n      }\n\n      if (filters.classTypes.length > 0 && !filters.classTypes.includes(session.cleanedClass)) {\n        return false;\n      }\n\n      // Location filtering (support partial matches)\n      if ((filters as any).locations && (filters as any).locations.length > 0) {\n        const allowedLocations: string[] = (filters as any).locations;\n        const sessionLoc = (session.location || '').toLowerCase();\n        const matches = allowedLocations.some(loc => {\n          const l = (loc || '').toLowerCase();\n          if (!l) return false;\n          return sessionLoc.includes(l) || l.includes(sessionLoc) || sessionLoc === l;\n        });\n        if (!matches) return false;\n      }\n\n      if (filters.dayOfWeek.length > 0 && !filters.dayOfWeek.includes(session.dayOfWeek)) {\n        return false;\n      }\n\n      if (filters.timeSlots.length > 0 && !filters.timeSlots.includes(session.time)) {\n        return false;\n      }\n\n      // Date range filter with improved parsing\n      if (filters.dateRange.start || filters.dateRange.end) {\n        let sessionDate: Date;\n        \n        // Handle different date formats from the sheets\n        if (session.date.includes('/')) {\n          // Handle DD/MM/YYYY format\n          const parts = session.date.split('/');\n          if (parts.length === 3) {\n            const day = parseInt(parts[0]);\n            const month = parseInt(parts[1]);\n            const year = parseInt(parts[2]);\n            sessionDate = new Date(year, month - 1, day);\n          } else {\n            sessionDate = new Date(session.date);\n          }\n        } else {\n          // Handle YYYY-MM-DD format\n          sessionDate = new Date(session.date);\n        }\n        \n        // Ensure we have a valid date\n        if (isNaN(sessionDate.getTime())) {\n          console.warn('Invalid date format:', session.date);\n          return true; // Don't exclude if we can't parse the date\n        }\n        \n        // Compare dates (ignore time component)\n        const sessionDateOnly = new Date(sessionDate.getFullYear(), sessionDate.getMonth(), sessionDate.getDate());\n        \n        if (filters.dateRange.start) {\n          const startDateOnly = new Date(filters.dateRange.start.getFullYear(), filters.dateRange.start.getMonth(), filters.dateRange.start.getDate());\n          if (sessionDateOnly < startDateOnly) {\n            return false;\n          }\n        }\n        \n        if (filters.dateRange.end) {\n          const endDateOnly = new Date(filters.dateRange.end.getFullYear(), filters.dateRange.end.getMonth(), filters.dateRange.end.getDate());\n          if (sessionDateOnly > endDateOnly) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    });\n  }, [data, filters]);\n\n  return filteredData;\n};\n"],"names":["SessionsFiltersContext","React.createContext","useSessionsFilters","context","React.useContext","SessionsFiltersProvider","children","filters","setFilters","React.useState","previousMonth","getPreviousMonthDateRange","updateFilters","newFilters","prev","clearFilters","clearAllFilters","jsx","useFilteredSessionsData","data","useMemo","session","sessionName","allowedLocations","sessionLoc","loc","sessionDate","parts","day","month","year","sessionDateOnly","startDateOnly","endDateOnly"],"mappings":"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"}