{"version":3,"file":"useGoogleSheets-BPVLuLVa.js","sources":["../../src/utils/performanceOptimizations.ts","../../src/hooks/useGoogleSheets.ts"],"sourcesContent":["/**\n * Advanced Performance Optimizations\n * Implements multiple strategies to improve app loading and runtime performance\n */\n\nimport { useEffect, useRef, useCallback } from 'react';\n\n// ==================== MEMOIZATION & CACHING ====================\n\n/**\n * Enhanced memoization with size limits and TTL\n */\nexport function createMemoCache<T = any>(maxSize = 100, ttl = 5 * 60 * 1000) {\n  const cache = new Map<string, { value: T; timestamp: number }>();\n  \n  return {\n    get(key: string): T | undefined {\n      const entry = cache.get(key);\n      if (!entry) return undefined;\n      \n      // Check if expired\n      if (Date.now() - entry.timestamp > ttl) {\n        cache.delete(key);\n        return undefined;\n      }\n      \n      return entry.value;\n    },\n    \n    set(key: string, value: T): void {\n      // Implement LRU-style eviction\n      if (cache.size >= maxSize) {\n        const firstKey = cache.keys().next().value;\n        cache.delete(firstKey);\n      }\n      \n      cache.set(key, { value, timestamp: Date.now() });\n    },\n    \n    clear(): void {\n      cache.clear();\n    },\n    \n    size(): number {\n      return cache.size;\n    }\n  };\n}\n\n// ==================== VIRTUAL SCROLLING ====================\n\n/**\n * Hook for virtual scrolling large lists\n */\nexport function useVirtualScroll<T>(\n  items: T[],\n  itemHeight: number,\n  containerHeight: number,\n  overscan = 3\n) {\n  const [scrollTop, setScrollTop] = React.useState(0);\n  \n  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);\n  const endIndex = Math.min(\n    items.length - 1,\n    Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan\n  );\n  \n  const visibleItems = items.slice(startIndex, endIndex + 1);\n  const totalHeight = items.length * itemHeight;\n  const offsetY = startIndex * itemHeight;\n  \n  return {\n    visibleItems,\n    totalHeight,\n    offsetY,\n    onScroll: (e: React.UIEvent<HTMLDivElement>) => {\n      setScrollTop(e.currentTarget.scrollTop);\n    },\n    startIndex,\n    endIndex\n  };\n}\n\n// ==================== DEBOUNCE & THROTTLE ====================\n\n/**\n * Optimized debounce hook\n */\nexport function useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = React.useState(value);\n  \n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n    \n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  \n  return debouncedValue;\n}\n\n/**\n * Throttle hook for high-frequency events\n */\nexport function useThrottle<T>(value: T, limit: number): T {\n  const [throttledValue, setThrottledValue] = React.useState(value);\n  const lastRan = useRef(Date.now());\n  \n  useEffect(() => {\n    const handler = setTimeout(() => {\n      if (Date.now() - lastRan.current >= limit) {\n        setThrottledValue(value);\n        lastRan.current = Date.now();\n      }\n    }, limit - (Date.now() - lastRan.current));\n    \n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, limit]);\n  \n  return throttledValue;\n}\n\n// ==================== IMAGE OPTIMIZATION ====================\n\n/**\n * Lazy load images with IntersectionObserver\n */\nexport function useLazyImage(src: string, options?: IntersectionObserverInit) {\n  const [imageSrc, setImageSrc] = React.useState<string | undefined>(undefined);\n  const [isLoaded, setIsLoaded] = React.useState(false);\n  const imgRef = useRef<HTMLImageElement>(null);\n  \n  useEffect(() => {\n    if (!imgRef.current) return;\n    \n    const observer = new IntersectionObserver(([entry]) => {\n      if (entry.isIntersecting) {\n        setImageSrc(src);\n        observer.disconnect();\n      }\n    }, options);\n    \n    observer.observe(imgRef.current);\n    \n    return () => observer.disconnect();\n  }, [src, options]);\n  \n  return { imgRef, imageSrc, isLoaded, setIsLoaded };\n}\n\n// ==================== DATA PROCESSING ====================\n\n/**\n * Process large datasets in chunks to avoid blocking\n */\nexport async function processDataInChunks<T, R>(\n  data: T[],\n  processor: (item: T) => R,\n  chunkSize = 100\n): Promise<R[]> {\n  const results: R[] = [];\n  \n  for (let i = 0; i < data.length; i += chunkSize) {\n    const chunk = data.slice(i, i + chunkSize);\n    \n    // Process chunk\n    const chunkResults = chunk.map(processor);\n    results.push(...chunkResults);\n    \n    // Yield to browser between chunks\n    if (i + chunkSize < data.length) {\n      await new Promise(resolve => setTimeout(resolve, 0));\n    }\n  }\n  \n  return results;\n}\n\n/**\n * Web Worker for heavy computations\n */\nexport function useWebWorker<T, R>(\n  workerFunction: (data: T) => R\n): [(data: T) => Promise<R>, boolean] {\n  const [isProcessing, setIsProcessing] = React.useState(false);\n  const workerRef = useRef<Worker | null>(null);\n  \n  const process = useCallback((data: T): Promise<R> => {\n    return new Promise((resolve, reject) => {\n      setIsProcessing(true);\n      \n      // Create worker blob\n      const blob = new Blob([`\n        self.onmessage = function(e) {\n          const result = (${workerFunction.toString()})(e.data);\n          self.postMessage(result);\n        };\n      `], { type: 'application/javascript' });\n      \n      const worker = new Worker(URL.createObjectURL(blob));\n      workerRef.current = worker;\n      \n      worker.onmessage = (e) => {\n        setIsProcessing(false);\n        resolve(e.data);\n        worker.terminate();\n      };\n      \n      worker.onerror = (error) => {\n        setIsProcessing(false);\n        reject(error);\n        worker.terminate();\n      };\n      \n      worker.postMessage(data);\n    });\n  }, [workerFunction]);\n  \n  useEffect(() => {\n    return () => {\n      workerRef.current?.terminate();\n    };\n  }, []);\n  \n  return [process, isProcessing];\n}\n\n// ==================== REQUEST OPTIMIZATION ====================\n\n/**\n * Request deduplication - prevents duplicate requests\n */\nclass RequestCache {\n  private pending = new Map<string, Promise<any>>();\n  private cache = new Map<string, { data: any; timestamp: number }>();\n  private ttl: number;\n  \n  constructor(ttl = 60000) {\n    this.ttl = ttl;\n  }\n  \n  async fetch<T>(key: string, fetcher: () => Promise<T>): Promise<T> {\n    // Return cached if valid\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.ttl) {\n      return cached.data;\n    }\n    \n    // Return pending request if exists\n    if (this.pending.has(key)) {\n      return this.pending.get(key);\n    }\n    \n    // Create new request\n    const promise = fetcher().then(data => {\n      this.cache.set(key, { data, timestamp: Date.now() });\n      this.pending.delete(key);\n      return data;\n    }).catch(error => {\n      this.pending.delete(key);\n      throw error;\n    });\n    \n    this.pending.set(key, promise);\n    return promise;\n  }\n  \n  clear() {\n    this.pending.clear();\n    this.cache.clear();\n  }\n}\n\nexport const requestCache = new RequestCache();\n\n// ==================== DOM OPTIMIZATION ====================\n\n/**\n * Batch DOM reads/writes to avoid layout thrashing\n */\nexport class DOMScheduler {\n  private readQueue: (() => void)[] = [];\n  private writeQueue: (() => void)[] = [];\n  private scheduled = false;\n  \n  scheduleRead(fn: () => void) {\n    this.readQueue.push(fn);\n    this.schedule();\n  }\n  \n  scheduleWrite(fn: () => void) {\n    this.writeQueue.push(fn);\n    this.schedule();\n  }\n  \n  private schedule() {\n    if (this.scheduled) return;\n    this.scheduled = true;\n    \n    requestAnimationFrame(() => {\n      // Execute all reads\n      const reads = [...this.readQueue];\n      this.readQueue = [];\n      reads.forEach(fn => fn());\n      \n      // Execute all writes\n      const writes = [...this.writeQueue];\n      this.writeQueue = [];\n      writes.forEach(fn => fn());\n      \n      this.scheduled = false;\n    });\n  }\n}\n\nexport const domScheduler = new DOMScheduler();\n\n// ==================== COMPONENT OPTIMIZATION ====================\n\n/**\n * Detect if component should skip render\n */\nexport function useSkipRender<T extends Record<string, any>>(\n  props: T,\n  compareFn?: (prev: T, next: T) => boolean\n): boolean {\n  const prevProps = useRef<T>(props);\n  const shouldSkip = useRef(false);\n  \n  useEffect(() => {\n    if (compareFn) {\n      shouldSkip.current = compareFn(prevProps.current, props);\n    } else {\n      shouldSkip.current = Object.keys(props).every(\n        key => prevProps.current[key] === props[key]\n      );\n    }\n    \n    prevProps.current = props;\n  });\n  \n  return shouldSkip.current;\n}\n\n/**\n * Intersection Observer hook for lazy rendering\n */\nexport function useInView(options?: IntersectionObserverInit) {\n  const [inView, setInView] = React.useState(false);\n  const [hasBeenInView, setHasBeenInView] = React.useState(false);\n  const ref = useRef<HTMLElement>(null);\n  \n  useEffect(() => {\n    if (!ref.current) return;\n    \n    const observer = new IntersectionObserver(([entry]) => {\n      setInView(entry.isIntersecting);\n      if (entry.isIntersecting) {\n        setHasBeenInView(true);\n      }\n    }, options);\n    \n    observer.observe(ref.current);\n    \n    return () => observer.disconnect();\n  }, [options]);\n  \n  return { ref, inView, hasBeenInView };\n}\n\n// Fix React import\nimport * as React from 'react';\n","\nimport { useState, useEffect, useRef, useMemo } from 'react';\nimport { SalesData } from '@/types/dashboard';\nimport { requestCache } from '@/utils/performanceOptimizations';\nimport { getGoogleAccessToken, parseNumericValue } from '@/utils/googleAuth';\nimport { createLogger } from '@/utils/logger';\n\nconst logger = createLogger('useGoogleSheets');\n\nconst SPREADSHEET_ID = \"1HbGnJk-peffUp7XoXSlsL55924E9yUt8cP_h93cdTT0\";\n\nexport const useGoogleSheets = () => {\n  const [data, setData] = useState<SalesData[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const isMountedRef = useRef(true);\n\n  const fetchSalesData = async () => {\n    // Abort previous request if still pending\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    \n    abortControllerRef.current = new AbortController();\n    \n    try {\n      setLoading(true);\n      setError(null);\n      \n      // Use request cache to prevent duplicate requests\n      const result = await requestCache.fetch('google-sheets-sales', async () => {\n        logger.info('Fetching sales data from Google Sheets...');\n        const accessToken = await getGoogleAccessToken();\n        \n        const response = await fetch(\n          `https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/Sales?alt=json`,\n          {\n            headers: {\n              'Authorization': `Bearer ${accessToken}`,\n            },\n            signal: abortControllerRef.current?.signal,\n          }\n        );\n\n        if (!response.ok) {\n          throw new Error('Failed to fetch data');\n        }\n\n        return response.json();\n      });\n      \n      const rows = result.values || [];\n      \n      // Raw data from Google Sheets received\n      \n      if (rows.length < 2) {\n        if (isMountedRef.current) {\n          setData([]);\n          setLoading(false);\n        }\n        return;\n      }\n\n      const headers = rows[0];\n      \n      // Process data in chunks to avoid blocking UI\n      const salesData: SalesData[] = [];\n      const chunkSize = 200; // Increased chunk size for better performance\n      \n      for (let i = 1; i < rows.length; i += chunkSize) {\n        // Check if component is still mounted\n        if (!isMountedRef.current) return;\n        \n        const end = Math.min(i + chunkSize, rows.length);\n        const batch = rows.slice(i, end).map((row: any[]) => {\n          const rawItem: any = {};\n          headers.forEach((header: string, index: number) => {\n            rawItem[header] = row[index] || '';\n          });\n\n          // Transform to match SalesData interface with camelCase field names\n          const transformedItem: SalesData = {\n            memberId: rawItem['Member ID'] || rawItem['memberId'] || '',\n            customerName: rawItem['Customer Name'] || rawItem['customerName'] || '',\n            customerEmail: rawItem['Customer Email'] || rawItem['customerEmail'] || '',\n            saleItemId: rawItem['Sale Item ID'] || rawItem['saleItemId'] || '',\n            paymentCategory: rawItem['Payment Category'] || rawItem['paymentCategory'] || '',\n            membershipType: rawItem['Membership Type'] || rawItem['membershipType'] || '',\n            paymentDate: rawItem['Payment Date'] || rawItem['paymentDate'] || '',\n            paymentValue: parseNumericValue(rawItem['Payment Value'] || rawItem['paymentValue'] || 0),\n            paidInMoneyCredits: parseNumericValue(rawItem['Paid in Money Credits'] || rawItem['Paid In Money Credits'] || rawItem['paidInMoneyCredits'] || 0),\n            paymentVAT: parseNumericValue(rawItem['Payment VAT'] || rawItem['paymentVAT'] || 0),\n            paymentItem: rawItem['Payment Item'] || rawItem['paymentItem'] || '',\n            paymentStatus: rawItem['Payment Status'] || rawItem['paymentStatus'] || '',\n            paymentMethod: rawItem['Payment Method'] || rawItem['paymentMethod'] || '',\n            paymentTransactionId: rawItem['Payment Transaction ID'] || rawItem['paymentTransactionId'] || '',\n            stripeToken: rawItem['Stripe Token'] || rawItem['stripeToken'] || '',\n            soldBy: rawItem['Sold By'] || rawItem['soldBy'] || '',\n            saleReference: rawItem['Sale Reference'] || rawItem['saleReference'] || '',\n            calculatedLocation: rawItem['Calculated Location'] || rawItem['calculatedLocation'] || '',\n            cleanedProduct: rawItem['Cleaned Product'] || rawItem['cleanedProduct'] || '',\n            cleanedCategory: rawItem['Cleaned Category'] || rawItem['cleanedCategory'] || '',\n            \n            // Calculate derived fields\n            netRevenue: parseNumericValue(rawItem['Payment Value'] || rawItem['paymentValue'] || 0) - parseNumericValue(rawItem['Payment VAT'] || rawItem['paymentVAT'] || 0),\n            vat: parseNumericValue(rawItem['Payment VAT'] || rawItem['paymentVAT'] || 0),\n            grossRevenue: parseNumericValue(rawItem['Payment Value'] || rawItem['paymentValue'] || 0),\n            \n            // Handle discount columns with multiple possible names\n            // Priority: Check primary discount columns first, then sale-level totals, then item-level values\n            mrpPreTax: parseNumericValue(\n              rawItem['Mrp - Pre Tax'] || rawItem['MRP Pre Tax'] || rawItem['MRP_Pre_Tax'] || \n              rawItem['mrpPreTax'] || rawItem['MrpPreTax'] || rawItem['Pre Tax MRP'] || \n              rawItem['Sale Item Unit Price Excluding VAT'] || 0\n            ),\n            mrpPostTax: parseNumericValue(\n              rawItem['Mrp - Post Tax'] || rawItem['MRP Post Tax'] || rawItem['MRP_Post_Tax'] || \n              rawItem['mrpPostTax'] || rawItem['MrpPostTax'] || rawItem['Post Tax MRP'] || \n              rawItem['Sale Item Unit Price Including VAT'] || 0\n            ),\n            discountAmount: parseNumericValue(\n              rawItem['Discount Amount -Mrp- Payment Value'] || rawItem['Discount Amount'] || \n              rawItem['discount_amount'] || rawItem['discountAmount'] || rawItem['DiscountAmount'] ||\n              rawItem['Discount_Amount'] || rawItem['Total Discount'] || rawItem['Discount Value In Currency'] || rawItem['Discount Value'] || rawItem['Discount Value (In Currency)'] || \n              rawItem['Sale Total Discount Value'] || rawItem['Sale Total Discount'] || rawItem['Sale Item Unit Discount Value'] || 0\n            ),\n            discountPercentage: parseNumericValue(\n              rawItem['Discount Percentage - discount amount/mrp*100'] || rawItem['Discount Percentage'] || \n              rawItem['discount_percentage'] || rawItem['discountPercentage'] || rawItem['DiscountPercentage'] ||\n              rawItem['Discount_Percentage'] || rawItem['Discount %'] || rawItem['Discount_Percent'] || 0\n            ),\n            hostId: rawItem['Host Id'] || rawItem['Host ID'] || rawItem['hostId'] || '',\n            // Secondary (Sec.) fields for behavior analytics\n            secMembershipStartDate: rawItem['Sec. Membership Start Date'] || rawItem['Sec Membership Start Date'] || '',\n            secMembershipEndDate: rawItem['Sec. Membership End Date'] || rawItem['Sec Membership End Date'] || '',\n            secMembershipTotalClasses: parseNumericValue(rawItem['Sec. Membership Total Classes'] || 0),\n            secMembershipClassesLeft: parseNumericValue(rawItem['Sec. Membership Classes Left'] || 0),\n            secMembershipUsedSessions: parseNumericValue(rawItem['Sec. Total Used Sessions'] || rawItem['Sec. Membership Used Sessions'] || 0),\n            // Additional discount indicators\n            discountType: rawItem['Discount Code'] ? 'code' : undefined,\n            isPromotional: !!(rawItem['Discount Code'] || rawItem['Purchase Type'] === 'promotional')\n          };\n\n          // Compute fallback discount metrics when missing\n          const itemUnitDiscount = parseNumericValue(rawItem['Sale Item Unit Discount Value'] || 0);\n          const mrp = transformedItem.mrpPostTax && transformedItem.mrpPostTax > 0\n            ? transformedItem.mrpPostTax\n            : (transformedItem.mrpPreTax || 0);\n\n          // If discountAmount is still 0 but item-level discount exists, use it\n          if ((transformedItem.discountAmount || 0) <= 0 && itemUnitDiscount > 0) {\n            transformedItem.discountAmount = itemUnitDiscount;\n          }\n\n          // Fallback: derive discountAmount from MRP vs payment when column is missing/0\n          if ((transformedItem.discountAmount || 0) <= 0 && mrp > 0 && (transformedItem.paymentValue || 0) > 0 && mrp > (transformedItem.paymentValue || 0)) {\n            transformedItem.discountAmount = mrp - (transformedItem.paymentValue || 0);\n          }\n\n          // Additional fallback: if still 0 but explicit percentage exists, compute amount\n          if ((transformedItem.discountAmount || 0) <= 0 && (transformedItem.discountPercentage || 0) > 0 && mrp > 0) {\n            transformedItem.discountAmount = (mrp * (transformedItem.discountPercentage || 0)) / 100;\n          }\n\n          // Fallback: derive discountPercentage if missing/0\n          if ((transformedItem.discountPercentage || 0) <= 0) {\n            if (mrp > 0 && (transformedItem.discountAmount || 0) > 0) {\n              transformedItem.discountPercentage = (transformedItem.discountAmount! / mrp) * 100;\n            } else if (mrp > 0 && (transformedItem.paymentValue || 0) > 0 && mrp > (transformedItem.paymentValue || 0)) {\n              transformedItem.discountPercentage = ((mrp - (transformedItem.paymentValue || 0)) / mrp) * 100;\n            } else if ((transformedItem.discountAmount || 0) > 0 && (transformedItem.paymentValue || 0) > 0) {\n              // Assume effective MRP = payment + discount when MRP is not available\n              const effectiveMrp = (transformedItem.paymentValue || 0) + (transformedItem.discountAmount || 0);\n              transformedItem.discountPercentage = effectiveMrp > 0 ? ((transformedItem.discountAmount || 0) / effectiveMrp) * 100 : 0;\n            }\n          }\n\n          // Normalize rounding\n          if (typeof transformedItem.discountAmount === 'number') {\n            transformedItem.discountAmount = Math.round(transformedItem.discountAmount * 100) / 100;\n          }\n          if (typeof transformedItem.discountPercentage === 'number') {\n            transformedItem.discountPercentage = Math.round(transformedItem.discountPercentage * 100) / 100;\n          }\n\n          return transformedItem;\n        });\n        \n        salesData.push(...batch);\n      }\n      \n      if (!isMountedRef.current) return;\n      \n      logger.debug('Transformed sales data sample:', salesData.slice(0, 3));\n      \n      // Enhanced debug logging for discount data (show more header/field variants to aid debugging)\n      const discountedItems = salesData.filter(item => (item.discountAmount || 0) > 0 || (item.discountPercentage || 0) > 0);\n      // Detect discount/mrp-like headers to help debugging\n      const foundDiscountHeaders = headers.filter((h: string) => /discount/i.test(h));\n      const foundMrpHeaders = headers.filter((h: string) => /mrp|mrp post|mrp - post|post tax/i.test(h));\n\n      const sampleRowValuesForFoundHeaders: Record<string, any> = {};\n      if (rows[1]) {\n        headers.forEach((header: string, idx: number) => {\n          if (foundDiscountHeaders.includes(header) || foundMrpHeaders.includes(header)) {\n            sampleRowValuesForFoundHeaders[header] = rows[1][idx] || null;\n          }\n        });\n      }\n\n      logger.info('useGoogleSheets - Data summary:', {\n        totalRecords: salesData.length,\n        recordsWithDiscounts: discountedItems.length,\n        samplePaymentDates: salesData.slice(0, 5).map(d => d.paymentDate),\n        sampleRawHeaders: headers ? headers.slice(0, 30) : undefined,\n        sampleRawRow: rows[1] ? rows[1].slice(0, 30) : undefined,\n        foundDiscountHeaders,\n        foundMrpHeaders,\n        sampleRowValuesForFoundHeaders,\n        sampleDiscountData: salesData.slice(0, 5).map(d => ({\n          date: d.paymentDate,\n          paymentValue: d.paymentValue,\n          mrpPreTax: d.mrpPreTax,\n          mrpPostTax: d.mrpPostTax,\n          discountAmount: d.discountAmount,\n          discountPercentage: d.discountPercentage,\n          discountValueInCurrency: d['Discount Value In Currency'] || d['discountValueInCurrency'] || undefined,\n          location: d.calculatedLocation\n        }))\n      });\n      \n      // Update state with processed data\n      setData(salesData);\n      setError(null);\n    } catch (err) {\n      if (isMountedRef.current) {\n        logger.error('Error fetching sales data:', err);\n        setError('Failed to load sales data');\n      }\n    } finally {\n      if (isMountedRef.current) {\n        setLoading(false);\n      }\n    }\n  };\n\n  useEffect(() => {\n    isMountedRef.current = true;\n    fetchSalesData();\n    \n    return () => {\n      isMountedRef.current = false;\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  return { data, loading, error, refetch: fetchSalesData };\n};\n"],"names":["RequestCache","ttl","__publicField","key","fetcher","cached","promise","data","error","requestCache","logger","createLogger","SPREADSHEET_ID","useGoogleSheets","setData","useState","loading","setLoading","setError","abortControllerRef","useRef","isMountedRef","fetchSalesData","rows","accessToken","getGoogleAccessToken","response","headers","salesData","chunkSize","i","end","batch","row","rawItem","header","index","transformedItem","parseNumericValue","itemUnitDiscount","mrp","effectiveMrp","discountedItems","item","foundDiscountHeaders","h","foundMrpHeaders","sampleRowValuesForFoundHeaders","idx","d","useEffect"],"mappings":"uQA8OA,MAAMA,CAAa,CAKjB,YAAYC,EAAM,IAAO,CAJjBC,EAAA,mBAAc,KACdA,EAAA,iBAAY,KACZA,EAAA,YAGN,KAAK,IAAMD,CACb,CAEA,MAAM,MAASE,EAAaC,EAAuC,CAEjE,MAAMC,EAAS,KAAK,MAAM,IAAIF,CAAG,EACjC,GAAIE,GAAU,KAAK,IAAA,EAAQA,EAAO,UAAY,KAAK,IACjD,OAAOA,EAAO,KAIhB,GAAI,KAAK,QAAQ,IAAIF,CAAG,EACtB,OAAO,KAAK,QAAQ,IAAIA,CAAG,EAI7B,MAAMG,EAAUF,EAAA,EAAU,KAAKG,IAC7B,KAAK,MAAM,IAAIJ,EAAK,CAAE,KAAAI,EAAM,UAAW,KAAK,IAAA,EAAO,EACnD,KAAK,QAAQ,OAAOJ,CAAG,EAChBI,EACR,EAAE,MAAMC,GAAS,CAChB,WAAK,QAAQ,OAAOL,CAAG,EACjBK,CACR,CAAC,EAED,YAAK,QAAQ,IAAIL,EAAKG,CAAO,EACtBA,CACT,CAEA,OAAQ,CACN,KAAK,QAAQ,MAAA,EACb,KAAK,MAAM,MAAA,CACb,CACF,CAEO,MAAMG,EAAe,IAAIT,EChR1BU,EAASC,EAA8B,EAEvCC,EAAiB,+CAEVC,EAAkB,IAAM,CACnC,KAAM,CAACN,EAAMO,CAAO,EAAIC,EAAAA,SAAsB,CAAA,CAAE,EAC1C,CAACC,EAASC,CAAU,EAAIF,EAAAA,SAAS,EAAI,EACrC,CAACP,EAAOU,CAAQ,EAAIH,EAAAA,SAAwB,IAAI,EAChDI,EAAqBC,EAAAA,OAA+B,IAAI,EACxDC,EAAeD,EAAAA,OAAO,EAAI,EAE1BE,EAAiB,SAAY,CAE7BH,EAAmB,SACrBA,EAAmB,QAAQ,MAAA,EAG7BA,EAAmB,QAAU,IAAI,gBAEjC,GAAI,CACFF,EAAW,EAAI,EACfC,EAAS,IAAI,EAwBb,MAAMK,GArBS,MAAMd,EAAa,MAAM,sBAAuB,SAAY,CACzEC,EAAO,KAAK,2CAA2C,EACvD,MAAMc,EAAc,MAAMC,EAAA,EAEpBC,EAAW,MAAM,MACrB,iDAAiDd,CAAc,yBAC/D,CACE,QAAS,CACP,cAAiB,UAAUY,CAAW,EAAA,EAExC,OAAQL,EAAmB,SAAS,MAAA,CACtC,EAGF,GAAI,CAACO,EAAS,GACZ,MAAM,IAAI,MAAM,sBAAsB,EAGxC,OAAOA,EAAS,KAAA,CAClB,CAAC,GAEmB,QAAU,CAAA,EAI9B,GAAIH,EAAK,OAAS,EAAG,CACfF,EAAa,UACfP,EAAQ,CAAA,CAAE,EACVG,EAAW,EAAK,GAElB,MACF,CAEA,MAAMU,EAAUJ,EAAK,CAAC,EAGhBK,EAAyB,CAAA,EACzBC,EAAY,IAElB,QAASC,EAAI,EAAGA,EAAIP,EAAK,OAAQO,GAAKD,EAAW,CAE/C,GAAI,CAACR,EAAa,QAAS,OAE3B,MAAMU,EAAM,KAAK,IAAID,EAAID,EAAWN,EAAK,MAAM,EACzCS,EAAQT,EAAK,MAAMO,EAAGC,CAAG,EAAE,IAAKE,GAAe,CACnD,MAAMC,EAAe,CAAA,EACrBP,EAAQ,QAAQ,CAACQ,EAAgBC,IAAkB,CACjDF,EAAQC,CAAM,EAAIF,EAAIG,CAAK,GAAK,EAClC,CAAC,EAGD,MAAMC,EAA6B,CACjC,SAAUH,EAAQ,WAAW,GAAKA,EAAQ,UAAe,GACzD,aAAcA,EAAQ,eAAe,GAAKA,EAAQ,cAAmB,GACrE,cAAeA,EAAQ,gBAAgB,GAAKA,EAAQ,eAAoB,GACxE,WAAYA,EAAQ,cAAc,GAAKA,EAAQ,YAAiB,GAChE,gBAAiBA,EAAQ,kBAAkB,GAAKA,EAAQ,iBAAsB,GAC9E,eAAgBA,EAAQ,iBAAiB,GAAKA,EAAQ,gBAAqB,GAC3E,YAAaA,EAAQ,cAAc,GAAKA,EAAQ,aAAkB,GAClE,aAAcI,EAAkBJ,EAAQ,eAAe,GAAKA,EAAQ,cAAmB,CAAC,EACxF,mBAAoBI,EAAkBJ,EAAQ,uBAAuB,GAAKA,EAAQ,uBAAuB,GAAKA,EAAQ,oBAAyB,CAAC,EAChJ,WAAYI,EAAkBJ,EAAQ,aAAa,GAAKA,EAAQ,YAAiB,CAAC,EAClF,YAAaA,EAAQ,cAAc,GAAKA,EAAQ,aAAkB,GAClE,cAAeA,EAAQ,gBAAgB,GAAKA,EAAQ,eAAoB,GACxE,cAAeA,EAAQ,gBAAgB,GAAKA,EAAQ,eAAoB,GACxE,qBAAsBA,EAAQ,wBAAwB,GAAKA,EAAQ,sBAA2B,GAC9F,YAAaA,EAAQ,cAAc,GAAKA,EAAQ,aAAkB,GAClE,OAAQA,EAAQ,SAAS,GAAKA,EAAQ,QAAa,GACnD,cAAeA,EAAQ,gBAAgB,GAAKA,EAAQ,eAAoB,GACxE,mBAAoBA,EAAQ,qBAAqB,GAAKA,EAAQ,oBAAyB,GACvF,eAAgBA,EAAQ,iBAAiB,GAAKA,EAAQ,gBAAqB,GAC3E,gBAAiBA,EAAQ,kBAAkB,GAAKA,EAAQ,iBAAsB,GAG9E,WAAYI,EAAkBJ,EAAQ,eAAe,GAAKA,EAAQ,cAAmB,CAAC,EAAII,EAAkBJ,EAAQ,aAAa,GAAKA,EAAQ,YAAiB,CAAC,EAChK,IAAKI,EAAkBJ,EAAQ,aAAa,GAAKA,EAAQ,YAAiB,CAAC,EAC3E,aAAcI,EAAkBJ,EAAQ,eAAe,GAAKA,EAAQ,cAAmB,CAAC,EAIxF,UAAWI,EACTJ,EAAQ,eAAe,GAAKA,EAAQ,aAAa,GAAKA,EAAQ,aAC9DA,EAAQ,WAAgBA,EAAQ,WAAgBA,EAAQ,aAAa,GACrEA,EAAQ,oCAAoC,GAAK,CAAA,EAEnD,WAAYI,EACVJ,EAAQ,gBAAgB,GAAKA,EAAQ,cAAc,GAAKA,EAAQ,cAChEA,EAAQ,YAAiBA,EAAQ,YAAiBA,EAAQ,cAAc,GACxEA,EAAQ,oCAAoC,GAAK,CAAA,EAEnD,eAAgBI,EACdJ,EAAQ,qCAAqC,GAAKA,EAAQ,iBAAiB,GAC3EA,EAAQ,iBAAsBA,EAAQ,gBAAqBA,EAAQ,gBACnEA,EAAQ,iBAAsBA,EAAQ,gBAAgB,GAAKA,EAAQ,4BAA4B,GAAKA,EAAQ,gBAAgB,GAAKA,EAAQ,8BAA8B,GACvKA,EAAQ,2BAA2B,GAAKA,EAAQ,qBAAqB,GAAKA,EAAQ,+BAA+B,GAAK,CAAA,EAExH,mBAAoBI,EAClBJ,EAAQ,+CAA+C,GAAKA,EAAQ,qBAAqB,GACzFA,EAAQ,qBAA0BA,EAAQ,oBAAyBA,EAAQ,oBAC3EA,EAAQ,qBAA0BA,EAAQ,YAAY,GAAKA,EAAQ,kBAAuB,CAAA,EAE5F,OAAQA,EAAQ,SAAS,GAAKA,EAAQ,SAAS,GAAKA,EAAQ,QAAa,GAEzE,uBAAwBA,EAAQ,4BAA4B,GAAKA,EAAQ,2BAA2B,GAAK,GACzG,qBAAsBA,EAAQ,0BAA0B,GAAKA,EAAQ,yBAAyB,GAAK,GACnG,0BAA2BI,EAAkBJ,EAAQ,+BAA+B,GAAK,CAAC,EAC1F,yBAA0BI,EAAkBJ,EAAQ,8BAA8B,GAAK,CAAC,EACxF,0BAA2BI,EAAkBJ,EAAQ,0BAA0B,GAAKA,EAAQ,+BAA+B,GAAK,CAAC,EAEjI,aAAcA,EAAQ,eAAe,EAAI,OAAS,OAClD,cAAe,CAAC,EAAEA,EAAQ,eAAe,GAAKA,EAAQ,eAAe,IAAM,cAAA,EAIvEK,EAAmBD,EAAkBJ,EAAQ,+BAA+B,GAAK,CAAC,EAClFM,EAAMH,EAAgB,YAAcA,EAAgB,WAAa,EACnEA,EAAgB,WACfA,EAAgB,WAAa,EAkBlC,IAfKA,EAAgB,gBAAkB,IAAM,GAAKE,EAAmB,IACnEF,EAAgB,eAAiBE,IAI9BF,EAAgB,gBAAkB,IAAM,GAAKG,EAAM,IAAMH,EAAgB,cAAgB,GAAK,GAAKG,GAAOH,EAAgB,cAAgB,KAC7IA,EAAgB,eAAiBG,GAAOH,EAAgB,cAAgB,KAIrEA,EAAgB,gBAAkB,IAAM,IAAMA,EAAgB,oBAAsB,GAAK,GAAKG,EAAM,IACvGH,EAAgB,eAAkBG,GAAOH,EAAgB,oBAAsB,GAAM,MAIlFA,EAAgB,oBAAsB,IAAM,GAC/C,GAAIG,EAAM,IAAMH,EAAgB,gBAAkB,GAAK,EACrDA,EAAgB,mBAAsBA,EAAgB,eAAkBG,EAAO,YACtEA,EAAM,IAAMH,EAAgB,cAAgB,GAAK,GAAKG,GAAOH,EAAgB,cAAgB,GACtGA,EAAgB,oBAAuBG,GAAOH,EAAgB,cAAgB,IAAMG,EAAO,aACjFH,EAAgB,gBAAkB,GAAK,IAAMA,EAAgB,cAAgB,GAAK,EAAG,CAE/F,MAAMI,GAAgBJ,EAAgB,cAAgB,IAAMA,EAAgB,gBAAkB,GAC9FA,EAAgB,mBAAqBI,EAAe,GAAMJ,EAAgB,gBAAkB,GAAKI,EAAgB,IAAM,CACzH,EAIF,OAAI,OAAOJ,EAAgB,gBAAmB,WAC5CA,EAAgB,eAAiB,KAAK,MAAMA,EAAgB,eAAiB,GAAG,EAAI,KAElF,OAAOA,EAAgB,oBAAuB,WAChDA,EAAgB,mBAAqB,KAAK,MAAMA,EAAgB,mBAAqB,GAAG,EAAI,KAGvFA,CACT,CAAC,EAEDT,EAAU,KAAK,GAAGI,CAAK,CACzB,CAEA,GAAI,CAACX,EAAa,QAAS,OAE3BX,EAAO,MAAM,iCAAkCkB,EAAU,MAAM,EAAG,CAAC,CAAC,EAGpE,MAAMc,EAAkBd,EAAU,OAAOe,IAASA,EAAK,gBAAkB,GAAK,IAAMA,EAAK,oBAAsB,GAAK,CAAC,EAE/GC,EAAuBjB,EAAQ,OAAQkB,GAAc,YAAY,KAAKA,CAAC,CAAC,EACxEC,EAAkBnB,EAAQ,OAAQkB,GAAc,oCAAoC,KAAKA,CAAC,CAAC,EAE3FE,EAAsD,CAAA,EACxDxB,EAAK,CAAC,GACRI,EAAQ,QAAQ,CAACQ,EAAgBa,IAAgB,EAC3CJ,EAAqB,SAAST,CAAM,GAAKW,EAAgB,SAASX,CAAM,KAC1EY,EAA+BZ,CAAM,EAAIZ,EAAK,CAAC,EAAEyB,CAAG,GAAK,KAE7D,CAAC,EAGHtC,EAAO,KAAK,kCAAmC,CAC7C,aAAckB,EAAU,OACxB,qBAAsBc,EAAgB,OACtC,mBAAoBd,EAAU,MAAM,EAAG,CAAC,EAAE,IAAIqB,GAAKA,EAAE,WAAW,EAChE,iBAAkBtB,EAAUA,EAAQ,MAAM,EAAG,EAAE,EAAI,OACnD,aAAcJ,EAAK,CAAC,EAAIA,EAAK,CAAC,EAAE,MAAM,EAAG,EAAE,EAAI,OAC/C,qBAAAqB,EACA,gBAAAE,EACA,+BAAAC,EACA,mBAAoBnB,EAAU,MAAM,EAAG,CAAC,EAAE,IAAIqB,IAAM,CAClD,KAAMA,EAAE,YACR,aAAcA,EAAE,aAChB,UAAWA,EAAE,UACb,WAAYA,EAAE,WACd,eAAgBA,EAAE,eAClB,mBAAoBA,EAAE,mBACtB,wBAAyBA,EAAE,4BAA4B,GAAKA,EAAE,yBAA8B,OAC5F,SAAUA,EAAE,kBAAA,EACZ,CAAA,CACH,EAGDnC,EAAQc,CAAS,EACjBV,EAAS,IAAI,CACf,MAAc,CACRG,EAAa,SAEfH,EAAS,2BAA2B,CAExC,QAAA,CACMG,EAAa,SACfJ,EAAW,EAAK,CAEpB,CACF,EAEAiC,OAAAA,EAAAA,UAAU,KACR7B,EAAa,QAAU,GACvBC,EAAA,EAEO,IAAM,CACXD,EAAa,QAAU,GACnBF,EAAmB,SACrBA,EAAmB,QAAQ,MAAA,CAE/B,GACC,CAAA,CAAE,EAEE,CAAE,KAAAZ,EAAM,QAAAS,EAAS,MAAAR,EAAO,QAASc,CAAA,CAC1C"}